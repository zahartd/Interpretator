# Scheme

Язык будет состоять из:
 - Примитивных типов: целых чисел, bool-ов и _символов_ (идентификаторов).
 - Составных типов: пар и списков.
 - Переменных с синтаксической областью видимости.
 - Функций и лямбда-выражений.

Программа должна будет выполнять выражения языка и возвращать результат выполнения.

```
    1 => 1
    (+ 1 2) => 3
```
Обозначение `=>` в примерах здесь и далее разделяет выражение и результат его выполнения.

## Выполнение выражений
Выполнение языка происходит в 3 этапа:

**Токенизация** - преобразует текст программы в последовательность атомарных лексем. 

**Синтаксический анализ** - преобразует последовательность токенов в [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree).  AST в LISP-подобных языках программирования представляется в виде списков. 
   
**Вычисление** - рекурсивно обходит AST программы и преобразует его в соответствии с набором правил.

### Пример

Выражение 
```
    (+ 2 (/ -3 +4))
``` 
в результате токенизации превратится в список токенов:
```
    { 
        OpenParen(),
        Symbol("+"),
        Number(2),
        OpenParen(),
        Symbol("/"),
        Number(-3),
        Number(4),
        CloseParen(),
        CloseParen()
    }
```
     
 Последовательность токенов в результате синтаксического анализа
 превратится в дерево:
     
```
    Cell{
        Symbol("+"),
        Cell{
            Number(2),
            Cell{
                Cell{
                    Symbol("/"),
                    Cell{
                        Number(-3),
                        Cell{
                            Number(4),
                            nullptr
                        }
                    }
                }
                nullptr
            }
        }
    }
```
Результатом же выполнения выражения будет 

```
    (+ 2 (/ -3 +4)) => 1
```

## Виды токенов

- **Число:** `42`, `-4` или `+10`
- **Скобка:** `(` или `)`
- **Quote:** `'`
- **Dot:** `.`
- **Symbol:** Начинается с символов `[a-zA-Z<=>*/#]` и может содержать внутри символы `[a-zA-Z<=>*/#0-9?!-]`. Отдельные
  знаки `+` и `-` мы тоже считаем символами.
- **Boolean** - либо `#t`, либо `#f`. Можно или завести отдельный тип токена под него, или реализовать через `Symbol`.

### Пример выражения и потока токенов

```
'(+ 4 -5)

Quote OpenParen Symbol(+) Const(4) Const(-5) CloseParen
```

## Синтаксис scheme

* В простом случае выражения языка состоят из одного числа, boolean-а или идентификатора. В этом случае дерево разбора состоит из одной вершины - числа или идентификатора. Для представления числа нужно сделать отдельный класс, наследник `Object`. Для представления идентификатора тоже нужно сделать отдельный класс.

```
5
+
foo-bar
```

* Выражение может быть парой. Пара обозначается круглыми скобками с точкой между двумя элементами. Для пары тоже нужно завести отдельный класс. Например, для выражения `(1 . 2)` должно строиться дерево из 3-х элементов. Корнем дерева является пара с двумя потомками.

* Выражение может быть списком. Список - это одна из двух сущностей:

 1. Пустой список. Обозначается пустыми скобочками - `()`. Можно думать, что это объект-константа со специальной
    семантикой.
 2. Пара, в которой второй элемент это список. В этом случае первый элемент пары называется головой (head) списка, а
    второй - хвостом (tail).

Из этого определения следует, что список из трех элементов можно записать так:

```
(1 . (2 . (3 . ())))

 pair => pair => pair => ()
  |       |       |
  1       2       3
```

Однако так записывать списки неудобно и разработчики языка добавили сокращенную запись:

```
(1 2 3)
```

Так записывается "правильный" список (proper list). Заметьте, что парсер должен по обоим представлениям списка строить **одинаковое** синтаксическое дерево.

В языке также есть поддержка "неправильных" списков (improper list). В таком списке второй элемент самой вложенной пары не является пустым списком.

```
(1 . (2 . 3))
pair => pair => 3
  |       |
  1       2
```

Для таких списков тоже есть сокращенная запись:

```
(1  2 . 3)
```

Элементы списков могут любыми корректными выражениями:

```
((1 . 2) (3 4) 5)
(1 () (2 3 4) 5)
```

* Пустой список нужно представлять с помощью `nullptr`.

## Рекурсивный спуск

Грамматика языка `scheme` лежит в классе `LL(1)`. Это значит, что можно написать рекурсивный алгоритм разбора, который заглядывает всего на один токен вперёд.

В авторском решении удалось обойтись всего двумя взаимно рекурсивными функциями: `Read` и `ReadList`.

- `Read` читает произвольное значение.
- `ReadList` читает список, пару или список с точкой в конце.

`Read` заглядывает на 1 токен вперёд.

1. Если стоит число или имя, то выражение состоит из одного элемента.
2. Если же там стоит `(`, то нужно вызвать рекурсивно `ReadList`.

`ReadList` в цикле вызывает `Read`, пока не встретит `)`.

Поддержку `QuoteToken` в этой подзадаче делать необязательно, мы займемся этим дальше. Можете выкидывать `SyntaxError`, если такой токен все-таки попался.

### 1. Особая форма quote

В языке scheme существует ряд так называемых "особых форм". Одной из них является `quote` - операция, которая при вычислении просто возвращает свой аргумент, например

```scheme
$ (quote 1)
> 1

$ (quote (+ 1 2))
> (+ 1 2)
```

Также нужно поддержать специальный токен `'` - это синтаксический сахар для `quote`. То есть, `'1` = `(quote 1)`, `'(1 2)` = `(quote (1 2))` и так далее. Предлагается реализовывать поддержку `'` на уровне парсера, заменяя выражение с `'` на выражение с `quote`.

Примеры использования:

```scheme
$ '(+ 1 2)
> (+ 1 2)

$ (quote (quote 1))
> (quote 1)

$ (quote '1)
> (quote 1)
```

### 2. Integer

Для представления чисел используйте целочисленный тип `int64_t`, считаем, что переполнения не происходит.

### 3. Boolean

В тестах вы найдете функции `and`, `or` - логические выражения с _short-circuit evaluation_.

* `(and)`, `(and (= 2 2) (> 2 1))`
* `(or #t)`, `(or #t (crash everything))`

Они работают похоже на `&&` и `||` в C++ - вычисляют аргументы по порядку, останавливаясь, когда значение всего выражения уже не может поменяться. Их можно рассматривать как еще две особые формы.

При этом аргументами `and` и `or` могут быть не только boolean-ы, но и любые другие выражения. В scheme все выражения кроме `#f` считаются "истинными". Если вычисление дошло до последнего аргумента, и он не равен `#f`, то нужно его вернуть. Примеры:

* `(and 1 '1 (+ 1 2))` -> `3`, так как `1` и `'1` неявно истинны, а `(+ 1 2)` -> `3`
* `(and 3 4 (> 1 2) 5)` -> `#f`, так как `3` и `4` неявно истинны, а `(> 1 2)` вычисляется в `#f`

### 4. List

## Обработка ошибок

Интерпретатор различает 3 вида ошибок:

1. `SyntaxError`: ошибки синтаксиса. Возникают, когда программа не соответствует формальному синтаксису языка. Или когда программа неправильно использует особые формы.

2. `NameError`: ошибки обращения к неопределённым переменным.

3. `RuntimeError`: ошибки времени исполнения. К этим ошибкам относятся все остальные ошибки, которые могут возникнуть во время выполнения программы. Например: неправильное количество аргументов передано в функцию, неправильный тип аргумента.

**При этом на любых входных данных никаких других исключений и интерпретатора выбрасываться не должно.**

### If

Работает как if :D Возможны 2 формы записи.

* `(if condition true-branch)`
* `(if condition true-branch false-branch)`

Сначала вычисляет `condition` и проверяет значение на истинность (см. определение истинности). Затем вычисляет либо `true-branch`, либо `false-branch` и возвращает как результат всего `if`-а.

### Переменные

Поддержка переменных реализована с помощью особых форм `define` и `set!`.

```scheme
$ (define x 1)
> ()
$ x
> 1
```

Обратите внимание на возвращаемое значение `define`. Команда `set!` используется для изменения значения **существующей**
переменной:

```scheme
$ (define x 1)
> ()
$ (set! x 2)
$ x
> 2
$ (set! y 1)
> NameError
```

Еще есть особые формы `set-car!` и `set-cdr!`.

### Лямбда-функции

Синтаксис:

* `(lambda (x) (+ 1 x))`
* `(lambda (x y) (* y x))`
* `(lambda (x) (set! x (* x 2)) (+ 1 x))`
* `(lambda () 1)`

Создаёт новую функцию. Сначала перечисляется список аргументов функции, затем её тело. Тело может состоять из нескольких выражений, в этом случае они вычисляются по порядку а результат последнего выражения становится результатом функции.

Запись `(define (fn-name <args>) <body>)` эквивалентна `(define fn-name (lambda (<args>) <body>))`. То есть, запись `(define (inc x) (+ x 1))` создаёт новую функцию `inc`.

### Захват контекста

#### Lambda capture in C++

Также возможен и захват контекста. Синтаксис примерно совпадает с C++:

```c++
auto Range(int x) {
  return [&x] () {
    ++x;
    return x;
  };
}

void F() {
  auto r = Range(10);

  std::cout << r() << std::endl; // 11
  std::cout << r() << std::endl; // 12
}
```

В **Scheme**:

```scheme
$ (define range
    (lambda (x)
      (lambda ()
        (set! x (+ x 1))
        x)))

$ (define my-range (range 10))

$ (my-range)
> 11

$ (my-range)
> 12
```

Заметьте, что такой код на С++ содержит UB - ссылка на `x` становится висящей после выхода из `Range()`. В Scheme такого не происходит - объект должен жить, пока на него кто-либо ссылается.

Вложенных scope может быть сколь угодно много. Больше примеров использования лямбда-функций вы найдете в тестах.

## Mark-and-Sweep

Также написан сборщик мусора, работающий по алгоритму [Mark-and-Sweep](https://www.geeksforgeeks.org/mark-and-sweep-garbage-collection-algorithm/) - вкратце, он поддерживает граф связей объектов, а при очистке обходит его, начиная с корня, помечает достижимые объекты, затем удаляет непомеченные. Таким образом, компоненты связности, целиком недостижимые из корня, будут удалены - при использовании `std::shared_ptr` такого достичь нельзя.


## Дополнительные материалы

* Видеоурок [введение в scheme](https://www.youtube.com/watch?v=AqBxU-Zmx00) объяснит базовые конструкции языка.

* Референсное решение: `mit-scheme` (apt, brew), либо [этот онлайн-интерпретатор](https://inst.eecs.berkeley.edu/~cs61a/fa14/assets/interpreter/scheme.html)

## Further reading

* Книга [Build Your Own Lisp](http://www.buildyourownlisp.com/) разбирает детали реализации интерпретатора на языке C.

* Книга [Crafting Interpreters](http://craftinginterpreters.com/) разбирает реализацию интерпретатора для более сложного языка, чем LISP.
